<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Yu-Gi-Oh Deck Calculator</title>
  <style>
    /* Dark theme styling */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #e0e0e0;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    h1 {
      text-align: center;
    }
    .inputs, .card-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
      align-items: center;
    }
    label {
      flex: 1 0 100px;
    }
    input[type="number"], input[type="text"], input[type="range"] {
      padding: 5px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .card-row {
      border: 1px solid #555;
      padding: 10px;
      border-radius: 4px;
      width: 100%;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 5px;
      flex: 1;
      flex-wrap: wrap;
    }
    .error {
      color: #ff6666;
      margin-bottom: 10px;
    }
    #result {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      border: 2px solid;
      border-radius: 4px;
    }
    button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background-color: #0066cc;
      color: #fff;
      cursor: pointer;
    }
    button:hover {
      background-color: #004999;
    }
    .small-input {
      width: 60px;
    }
    /* Style for the remove button */
    .remove-btn {
      background-color: #cc0000;
      margin-left: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Yu-Gi-Oh Deck Calculator</h1>
    <p>
      This calculator uses hypergeometric probability to estimate the chance of drawing your desired hand.<br>
      Enter your deck size, hand size, and details for each card group. Adjust the dual sliders to set the minimum and maximum copies you want in your hand.
      The probability updates live as you type.
    </p>
    <div class="inputs">
      <label for="deckSize">Deck Size:</label>
      <input type="number" id="deckSize" value="40" min="1">
      <label for="handSize">Hand Size:</label>
      <input type="number" id="handSize" value="5" min="1">
    </div>
    <div id="rowsContainer"></div>
    <button id="addRow">+ Add Card Group</button>
    <div id="errorMessage" class="error"></div>
    <div id="result">Probability: N/A</div>
  </div>
  
  <script>
    // Global counter for unique datalist IDs
    let rowCounter = 0;

    // Utility function to compute binomial coefficients
    function binom(n, k) {
      if (k < 0 || k > n) return 0;
      if (k === 0 || k === n) return 1;
      let result = 1;
      for (let i = 1; i <= k; i++) {
        result *= (n - i + 1) / i;
      }
      return result;
    }
    
    // Calculate the overall probability that a hand meets all card group constraints.
    function calculateProbability() {
      const deckSize = parseInt(document.getElementById("deckSize").value) || 0;
      const handSize = parseInt(document.getElementById("handSize").value) || 0;
      let errorMsg = "";
      
      if (deckSize <= 0) {
        errorMsg = "Deck size must be greater than 0.";
        document.getElementById("errorMessage").textContent = errorMsg;
        return null;
      }
      if (handSize <= 0) {
        errorMsg = "Hand size must be greater than 0.";
        document.getElementById("errorMessage").textContent = errorMsg;
        return null;
      }
      if (handSize > deckSize) {
        errorMsg = "Hand size cannot exceed deck size.";
        document.getElementById("errorMessage").textContent = errorMsg;
        return null;
      }
      
      // Gather all card groups
      const rows = [];
      const rowElements = document.querySelectorAll(".card-row");
      let totalCopiesSpecified = 0;
      
      rowElements.forEach(row => {
        const copies = parseInt(row.querySelector(".copies").value) || 0;
        const minVal = parseInt(row.querySelector(".min-val").textContent) || 0;
        const maxVal = parseInt(row.querySelector(".max-val").textContent) || 0;
        totalCopiesSpecified += copies;
        rows.push({ copies, min: minVal, max: maxVal });
      });
      
      if (totalCopiesSpecified > deckSize) {
        errorMsg = "Total copies specified exceed deck size.";
        document.getElementById("errorMessage").textContent = errorMsg;
        return null;
      }
      
      document.getElementById("errorMessage").textContent = "";
      
      const R = deckSize - totalCopiesSpecified; // remaining cards not covered by specific groups
      const totalWays = binom(deckSize, handSize);
      
      // Recursively sum over all valid combinations of drawn copies for each card group.
      function rec(index, currentSum, prod) {
        if (index === rows.length) {
          const r = handSize - currentSum;
          if (r < 0 || r > R) return 0;
          return prod * binom(R, r);
        }
        let sumRow = 0;
        const row = rows[index];
        const lower = row.min;
        const upper = Math.min(row.max, row.copies);
        for (let x = lower; x <= upper; x++) {
          sumRow += rec(index + 1, currentSum + x, prod * binom(row.copies, x));
        }
        return sumRow;
      }
      
      const validHands = rec(0, 0, 1);
      const probability = validHands / totalWays;
      return probability;
    }
    
    // Update the probability display with appropriate color coding and emoji.
    function updateResult() {
      const prob = calculateProbability();
      const resultDiv = document.getElementById("result");
      if (prob === null) {
        resultDiv.textContent = "Probability: N/A";
        resultDiv.style.borderColor = "#555";
        resultDiv.style.color = "#e0e0e0";
        return;
      }
      const percent = (prob * 100).toFixed(2);
      let color = "red";
      if (prob >= 0.75) {
        color = "green";
      } else if (prob > 0.60) {
        color = "orange";
      }
      let emoji = "";
      if (prob >= 0.85) {
        emoji = " ðŸ’ª";
      }
      resultDiv.textContent = `Probability: ${percent}%${emoji}`;
      resultDiv.style.borderColor = color;
      resultDiv.style.color = color;
    }
    
    // Create and add a new card group row.
    function addRow() {
      rowCounter++;
      const rowsContainer = document.getElementById("rowsContainer");
      
      const rowDiv = document.createElement("div");
      rowDiv.className = "card-row";
      
      // Card Name Field
      const nameLabel = document.createElement("label");
      nameLabel.textContent = "Card Name:";
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.className = "card-name";
      nameInput.placeholder = "e.g., Blue-Eyes";
      nameInput.addEventListener("input", updateResult);
      
      // Copies in Deck Field
      const copiesLabel = document.createElement("label");
      copiesLabel.textContent = "Copies in Deck:";
      const copiesInput = document.createElement("input");
      copiesInput.type = "number";
      copiesInput.className = "copies small-input";
      copiesInput.value = 3;
      copiesInput.min = 0;
      copiesInput.addEventListener("input", function() {
        updateSliderRange(rowDiv);
        updateResult();
      });
      
      // Dual slider for minimum and maximum in hand.
      const sliderContainer = document.createElement("div");
      sliderContainer.className = "slider-container";
      
      const sliderText = document.createTextNode("In Hand: ");
      sliderContainer.appendChild(sliderText);
      
      const minSlider = document.createElement("input");
      minSlider.type = "range";
      minSlider.className = "min-slider";
      minSlider.min = 0;
      minSlider.value = 0;
      
      const minDisplay = document.createElement("span");
      minDisplay.className = "min-val";
      minDisplay.textContent = "0";
      
      const maxSlider = document.createElement("input");
      maxSlider.type = "range";
      maxSlider.className = "max-slider";
      maxSlider.min = 0;
      maxSlider.value = 0;
      
      const maxDisplay = document.createElement("span");
      maxDisplay.className = "max-val";
      maxDisplay.textContent = "0";
      
      // Create a datalist for tick marks with a unique ID.
      const tickDatalist = document.createElement("datalist");
      tickDatalist.id = "ticks" + rowCounter;
      minSlider.setAttribute("list", tickDatalist.id);
      maxSlider.setAttribute("list", tickDatalist.id);
      
      // Append the datalist to the slider container.
      sliderContainer.appendChild(minSlider);
      sliderContainer.appendChild(minDisplay);
      sliderContainer.appendChild(document.createTextNode(" to "));
      sliderContainer.appendChild(maxSlider);
      sliderContainer.appendChild(maxDisplay);
      sliderContainer.appendChild(tickDatalist);
      
      // Function to update slider values and ensure min â‰¤ max â‰¤ copies.
      function sliderChange() {
        let minVal = parseInt(minSlider.value);
        let maxVal = parseInt(maxSlider.value);
        const copiesVal = parseInt(copiesInput.value) || 0;
        if (minVal > maxVal) {
          maxVal = minVal;
          maxSlider.value = maxVal;
        }
        if (maxVal > copiesVal) {
          maxVal = copiesVal;
          maxSlider.value = maxVal;
        }
        if (minVal > copiesVal) {
          minVal = copiesVal;
          minSlider.value = minVal;
        }
        minDisplay.textContent = minVal;
        maxDisplay.textContent = maxVal;
        updateResult();
      }
      
      // Add listeners to both sliders so any adjustment updates the result.
      minSlider.addEventListener("input", sliderChange);
      maxSlider.addEventListener("input", sliderChange);
      
      rowDiv.appendChild(nameLabel);
      rowDiv.appendChild(nameInput);
      rowDiv.appendChild(copiesLabel);
      rowDiv.appendChild(copiesInput);
      rowDiv.appendChild(sliderContainer);
      
      // Add a remove button to allow deleting this row.
      const removeButton = document.createElement("button");
      removeButton.textContent = "Remove";
      removeButton.className = "remove-btn";
      removeButton.addEventListener("click", function() {
        rowDiv.remove();
        updateResult();
      });
      rowDiv.appendChild(removeButton);
      
      rowsContainer.appendChild(rowDiv);
      
      // Initialize the slider max values and tick marks based on the copies input.
      updateSliderRange(rowDiv);
    }
    
    // Update each row's sliders based on the current copies value and update tick marks.
    function updateSliderRange(rowDiv) {
      const copiesInput = rowDiv.querySelector(".copies");
      const copiesVal = parseInt(copiesInput.value) || 0;
      
      const minSlider = rowDiv.querySelector(".min-slider");
      const maxSlider = rowDiv.querySelector(".max-slider");
      
      minSlider.max = copiesVal;
      maxSlider.max = copiesVal;
      
      if (parseInt(minSlider.value) > copiesVal) {
        minSlider.value = copiesVal;
        rowDiv.querySelector(".min-val").textContent = copiesVal;
      }
      if (parseInt(maxSlider.value) > copiesVal) {
        maxSlider.value = copiesVal;
        rowDiv.querySelector(".max-val").textContent = copiesVal;
      }
      
      // Update tick marks in the datalist based on the new copies value.
      const tickDatalist = rowDiv.querySelector("datalist");
      if (tickDatalist) {
        tickDatalist.innerHTML = "";
        for (let i = 0; i <= copiesVal; i++) {
          const option = document.createElement("option");
          option.value = i;
          tickDatalist.appendChild(option);
        }
      }
    }
    
    // Listeners for deck size and hand size so changes update the result immediately.
    document.getElementById("deckSize").addEventListener("input", updateResult);
    document.getElementById("handSize").addEventListener("input", updateResult);
    document.getElementById("addRow").addEventListener("click", addRow);
    
    // Add an initial card group row.
    addRow();
    updateResult();
  </script>
</body>
</html>
