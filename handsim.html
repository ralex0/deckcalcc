<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Yu-Gi-Oh! Hand Simulator</title>
  <style>
    /* Global Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #121212;
      color: #e0e0e0;
      transition: background-color 0.3s, color 0.3s;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    #description {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.1em;
    }
    
    /* Top Controls */
    .top-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .top-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .top-controls button:hover {
      background: #777;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .control-group label {
      white-space: nowrap;
    }
    .control-group input[type="number"] {
      width: 100px;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    #calcResult {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      border: 2px solid;
      border-radius: 4px;
      width: 100%;
      margin-top: 10px;
      display: none;
    }
    
    /* Layout */
    .row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      align-items: start;
    }
    .left-pane, .right-pane {
      background: #2e2e2e;
      padding: 10px;
      border-radius: 6px;
    }
    .left-pane {
      min-height: 600px;
    }
    
    /* Headers */
    .deck-header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .deck-header {
      font-size: 1.2em;
      font-weight: bold;
    }
    .deck-header-container button {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .deck-header-container button:hover {
      background: #777;
    }
    
    /* Decklist */
    .decklist-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .decklist-row input[type="number"],
    .decklist-row input[type="text"] {
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .qty-field {
      width: 60px;
    }
    .card-name {
      flex: 2;
    }
    .aka-field {
      flex: 1;
    }
    .draw-field {
      width: 60px;
    }
    .decklist-buttons {
      display: flex;
      gap: 5px;
    }
    .decklist-buttons button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .decklist-buttons button:hover {
      background: #777;
    }
    
    /* Hand Building */
    .hand-size-control {
      display: flex;
      align-items: center;
      margin: 0;
    }
    .hand-size-control label {
      margin-right: 5px;
      white-space: nowrap;
    }
    .hand-size-control input {
      width: 50px;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .hand-box {
      border: 1px solid #555;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .hand-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 5px;
    }
    .hand-card-wrapper {
      display: flex;
      align-items: center;
    }
    .hand-card {
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
      appearance: menulist-button;
      width: 100%;
      min-width: 0;
    }
    .hand-toggle {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2em;
      margin-left: 5px;
    }
    .hand-toggle.active {
      color: red;
    }
    .hand-controls {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-top: 5px;
    }
    .hand-controls button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .hand-controls button:hover {
      background: #777;
    }
    
    /* Light Mode Overrides */
    body.light-mode {
      background: #f7f7f7;
      color: #000;
    }
    body.light-mode .container {
      background: #fff;
      color: #000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    body.light-mode .left-pane,
    body.light-mode .right-pane {
      background: #f0f0f0;
    }
    body.light-mode input[type="number"],
    body.light-mode input[type="text"] {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .decklist-buttons button,
    body.light-mode .hand-controls button,
    body.light-mode .top-controls button,
    body.light-mode .deck-header-container button {
      background: #ccc;
      color: #000;
    }
    body.light-mode .decklist-buttons button:hover,
    body.light-mode .hand-controls button:hover,
    body.light-mode .top-controls button:hover,
    body.light-mode .deck-header-container button:hover {
      background: #aaa;
    }
    body.light-mode .hand-card {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .hand-size-control input,
    body.light-mode .control-group input[type="number"] {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .decklist-row input.draw-field {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    
    /* Fixed Controls */
    #themeContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1001;
    }
    #themeToggle {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background: transparent;
      color: inherit;
      font-size: 1.5em;
      cursor: pointer;
      transition: background 0.3s;
    }
    body:not(.light-mode) #themeToggle:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    body.light-mode #themeToggle:hover {
      background: rgba(0, 0, 0, 0.1);
    }
    #donateContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Yu-Gi-Oh! Hand Simulator</h1>
    <p id="description">
      This tool simulates drawing hands from your Yu-Gi-Oh! deck. Import your deck, set your hand criteria (including exclusions and draw effects), choose the number of trials and hand size, then click Calculate.
    </p>
    <div class="top-controls">
      <div class="control-group">
        <label for="numTrials">Number of test hands to draw:</label>
        <input type="number" id="numTrials" value="100" min="1" />
      </div>
      <button id="calculateButton">Calculate</button>
    </div>
    <div id="calcResult">Result: Placeholder</div>
    <div class="row">
      <!-- Left Pane: Decklist -->
      <div class="left-pane">
        <div class="deck-header-container">
          <div id="decklistHeader" class="deck-header">Main Deck (0)</div>
          <button id="importDeckButton">Import deck...</button>
        </div>
        <div id="decklistContainer"></div>
      </div>
      <!-- Right Pane: Hand Targets -->
      <div class="right-pane">
        <div class="deck-header-container">
          <div id="handHeader" class="deck-header">Targets</div>
          <div class="hand-size-control">
            <label for="handSizeInput">Hand Size:</label>
            <input type="number" id="handSizeInput" value="5" min="1" />
          </div>
        </div>
        <div id="handContainer"></div>
        <datalist id="handOptions"></datalist>
      </div>
    </div>
    <input type="file" id="fileInput" accept=".ydk" style="display: none;" />
  </div>

  <!-- Theme and Donate Controls -->
  <div id="themeContainer">
    <button id="themeToggle">‚òÄÔ∏è</button>
  </div>
  <div id="donateContainer">
    <script src="https://storage.ko-fi.com/cdn/widget/Widget_2.js" type="text/javascript"></script>
    <script type="text/javascript">
      kofiwidget2.init('Support the dev', '#72a4f2', 'Q5Q51BKX92');
      kofiwidget2.draw();
    </script>
  </div>

  <script>
    // =============================
    // Helper Functions
    // =============================
    function createInput(type, value, className, min, onInput, placeholder) {
      const input = document.createElement('input');
      input.type = type;
      input.value = value;
      if (min !== null) input.min = min;
      if (className) input.className = className;
      if (placeholder) input.placeholder = placeholder;
      if (onInput) input.addEventListener('input', onInput);
      return input;
    }

    function createButton(text, title, onClick) {
      const btn = document.createElement('button');
      btn.textContent = text;
      btn.title = title;
      btn.addEventListener('click', onClick);
      return btn;
    }

    // Creates a hand card wrapper element (select and toggle)
    function createHandCardWrapper() {
      const wrapper = document.createElement('div');
      wrapper.className = 'hand-card-wrapper';

      const select = document.createElement('select');
      select.className = 'hand-card';
      const defaultOption = document.createElement('option');
      defaultOption.textContent = "Card name or tag";
      defaultOption.disabled = true;
      defaultOption.selected = true;
      select.appendChild(defaultOption);

      // Populate options from datalist
      const dl = document.getElementById('handOptions');
      Array.from(dl.options).forEach(o => {
        const option = document.createElement('option');
        option.value = o.value;
        option.textContent = o.value;
        select.appendChild(option);
      });

      select.addEventListener('blur', () => validateHandCardInput(select));

      const toggle = createButton('üõá', '', e => {
        e.preventDefault();
        toggle.classList.toggle('active');
        select.dataset.exclude = toggle.classList.contains('active');
      });
      toggle.className = 'hand-toggle';

      wrapper.append(select, toggle);
      return wrapper;
    }

    // =============================
    // Decklist Functions
    // =============================
    function createDecklistRow(q = 1, name = "", tags = "", draw = 0) {
      const row = document.createElement('div');
      row.className = 'decklist-row';

      const qtyInput = createInput('number', q, 'qty-field', 1, () => {
        updateDeckHeader();
        updateHandOptions();
      });
      const nameInput = createInput('text', name, 'card-name', null, updateHandOptions, 'Card Name');
      const tagsInput = createInput('text', tags, 'aka-field', null, updateHandOptions, 'List Tags: Starter, Handtrap, etc');
      const drawInput = createInput('number', draw, 'draw-field', 0, updateHandOptions, 'Draw');

      const btnContainer = document.createElement('div');
      btnContainer.className = 'decklist-buttons';
      const addBtn = createButton('+', 'Add row', () => {
        row.parentNode.insertBefore(createDecklistRow(), row.nextSibling);
        updateDeckHeader();
        updateHandOptions();
      });
      const removeBtn = createButton('‚Äì', 'Remove row', () => {
        const container = document.getElementById('decklistContainer');
        if (container.querySelectorAll('.decklist-row').length > 1) {
          row.remove();
        } else {
          qtyInput.value = 1;
          nameInput.value = "";
          tagsInput.value = "";
          drawInput.value = 0;
        }
        updateDeckHeader();
        updateHandOptions();
      });
      btnContainer.append(addBtn, removeBtn);

      row.append(qtyInput, nameInput, tagsInput, drawInput, btnContainer);
      return row;
    }

    function updateDeckHeader() {
      let total = 0;
      document.querySelectorAll('#decklistContainer .decklist-row').forEach(row => {
        total += parseInt(row.querySelector('input.qty-field').value) || 0;
      });
      document.getElementById('decklistHeader').textContent = `Main Deck (${total})`;
    }

    function initDecklist(data) {
      const container = document.getElementById('decklistContainer');
      container.innerHTML = "";
      if (!data.length) {
        container.appendChild(createDecklistRow());
      } else {
        data.forEach(item => {
          container.appendChild(createDecklistRow(item.quantity, item.cardName, item.tags || "", item.draw || 0));
        });
      }
      updateDeckHeader();
      updateHandOptions();
    }

    // =============================
    // Hand Functions
    // =============================
    function updateHandOptions() {
      const optionsSet = new Set();
      document.querySelectorAll('#decklistContainer .decklist-row').forEach(row => {
        const cardName = row.querySelector('input.card-name').value.trim();
        if (cardName) optionsSet.add(cardName);
        const tags = row.querySelector('input.aka-field').value;
        if (tags) {
          tags.split(',').forEach(tag => {
            if (tag.trim()) optionsSet.add(tag.trim());
          });
        }
      });
      const optionsArray = Array.from(optionsSet).sort((a, b) => a.localeCompare(b));
      optionsArray.unshift("[Any Card]");

      const dl = document.getElementById('handOptions');
      dl.innerHTML = "";
      optionsArray.forEach(opt => {
        const optionElem = document.createElement('option');
        optionElem.value = opt;
        dl.appendChild(optionElem);
      });

      updateAllHandRows();
      updateHandSelectOptions();
    }

    function updateHandSelectOptions() {
      const dl = document.getElementById('handOptions');
      const options = Array.from(dl.options).map(o => ({ value: o.value, text: o.value }));
      document.querySelectorAll('select.hand-card').forEach(select => {
        const currentVal = select.value;
        select.innerHTML = "";
        const defaultOption = document.createElement('option');
        defaultOption.textContent = "Card name or tag";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        select.appendChild(defaultOption);
        options.forEach(opt => {
          const optionElem = document.createElement('option');
          optionElem.value = opt.value;
          optionElem.textContent = opt.text;
          select.appendChild(optionElem);
        });
        if (options.map(o => o.value).includes(currentVal)) {
          select.value = currentVal;
        }
      });
    }

    function validateHandCardInput(input) {
      const val = input.value.trim();
      if (!val) return;
      const allowed = Array.from(document.getElementById('handOptions').options).map(o => o.value);
      if (!allowed.includes(val)) {
        const matched = allowed.find(v => v.toLowerCase() === val.toLowerCase());
        input.value = matched || "";
      }
    }

    function createHandRow() {
      const handBox = document.createElement('div');
      handBox.className = 'hand-box';

      const handRow = document.createElement('div');
      handRow.className = 'hand-row';
      const size = parseInt(document.getElementById('handSizeInput').value) || 5;
      for (let i = 0; i < size; i++) {
        handRow.appendChild(createHandCardWrapper());
      }

      const handControls = document.createElement('div');
      handControls.className = 'hand-controls';
      const addRowBtn = createButton('+', 'Add row', () => {
        handBox.parentNode.insertBefore(createHandRow(), handBox.nextSibling);
      });
      const removeRowBtn = createButton('‚Äì', 'Remove row', () => {
        const container = document.getElementById('handContainer');
        if (container.children.length > 1) {
          handBox.remove();
        } else {
          handRow.querySelectorAll('select.hand-card').forEach(select => (select.selectedIndex = 0));
        }
      });
      const duplicateRowBtn = createButton('‚ßâ', 'Duplicate row', () => {
        const newHandBox = createHandRow();
        const currentSelects = handBox.querySelectorAll('select.hand-card');
        const newSelects = newHandBox.querySelectorAll('select.hand-card');
        currentSelects.forEach((sel, i) => {
          newSelects[i].value = sel.value;
        });
        handBox.parentNode.insertBefore(newHandBox, handBox.nextSibling);
      });
      handControls.append(addRowBtn, removeRowBtn, duplicateRowBtn);

      handBox.append(handRow, handControls);
      return handBox;
    }

    function updateAllHandRows() {
      const size = parseInt(document.getElementById('handSizeInput').value) || 5;
      document.querySelectorAll('#handContainer .hand-box').forEach(handBox => {
        const handRow = handBox.querySelector('.hand-row');
        const currentCount = handRow.querySelectorAll('.hand-card').length;
        if (currentCount < size) {
          for (let i = currentCount; i < size; i++) {
            handRow.appendChild(createHandCardWrapper());
          }
        } else if (currentCount > size) {
          for (let i = currentCount; i > size; i--) {
            const wrappers = handRow.querySelectorAll('.hand-card-wrapper');
            wrappers[wrappers.length - 1].remove();
          }
        }
      });
      updateHandSelectOptions();
    }

    function initHandContainer() {
      const container = document.getElementById('handContainer');
      container.innerHTML = "";
      container.appendChild(createHandRow());
    }

    // =============================
    // File Integration Functions
    // =============================
    function parseYDK(text) {
      const lines = text.split(/\r?\n/);
      const main = [];
      let section = "main";
      lines.forEach(line => {
        line = line.trim();
        if (!line) return;
        if (line.startsWith("#")) {
          section = (line.toLowerCase() === "#main") ? "main" : "other";
          return;
        }
        if (line.startsWith("!")) {
          section = "other";
          return;
        }
        if (!isNaN(line) && section === "main") {
          main.push(line);
        }
      });
      return main;
    }

    async function fetchCardDetails(ids) {
      const uniqueIds = Array.from(new Set(ids));
      const param = uniqueIds.join(",");
      const res = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?utm_source=storm-access&misc=yes&id=${param}`);
      const payload = await res.json();
      const cardMap = new Map();
      payload.data.forEach(card => cardMap.set(String(card.id), card));
      return cardMap;
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(event) {
        const text = event.target.result;
        const ids = parseYDK(text);
        if (!ids.length) {
          alert('No cards found.');
          return;
        }
        try {
          const cardMap = await fetchCardDetails(ids);
          const counts = {};
          ids.forEach(id => {
            counts[id] = (counts[id] || 0) + 1;
          });
          const deckData = [];
          for (const id in counts) {
            const card = cardMap.get(id);
            deckData.push({
              quantity: counts[id],
              cardName: card ? card.name : `Unknown card (ID: ${id})`,
              tags: "",
              draw: 0
            });
          }
          initDecklist(deckData);
        } catch (err) {
          alert('Error fetching card details: ' + err);
        }
      };
      reader.readAsText(file);
    });

    // =============================
    // Simulation Logic
    // =============================
    function runSimulation() {
      const trials = parseInt(document.getElementById('numTrials').value) || 100;
      const deck = [];
      document.querySelectorAll('#decklistContainer .decklist-row').forEach(row => {
        const qty = parseInt(row.querySelector('input.qty-field').value) || 0;
        const name = row.querySelector('input.card-name').value.trim().toLowerCase();
        const tags = (row.querySelector('input.aka-field').value || "")
          .split(',')
          .map(s => s.trim().toLowerCase())
          .filter(Boolean);
        const draw = parseInt(row.querySelector('input.draw-field').value) || 0;
        for (let i = 0; i < qty; i++) {
          deck.push({ name, tags, draw });
        }
      });
      if (!deck.length) {
        alert("Deck is empty!");
        return;
      }

      const templates = [];
      document.querySelectorAll('#handContainer .hand-box').forEach(box => {
        const conditions = [];
        box.querySelectorAll('.hand-row select.hand-card').forEach(select => {
          const val = select.value.trim();
          if (val === "" || val === "Card name or tag") return;
          conditions.push({ value: val.toLowerCase(), exclude: (select.dataset.exclude === "true") });
        });
        if (conditions.length) templates.push(conditions);
      });
      if (!templates.length) {
        alert("No hand templates defined!");
        return;
      }

      let successes = 0;
      for (let t = 0; t < trials; t++) {
        let deckCopy = deck.slice();
        shuffle(deckCopy);
        const size = parseInt(document.getElementById('handSizeInput').value) || 5;
        let hand = deckCopy.splice(0, size);
        hand.forEach(card => card.processed = false);
        let success = false;
        if (checkHandTemplates(hand, templates)) {
          success = true;
        } else {
          while (true) {
            let extra = 0;
            hand.forEach(card => {
              if (!card.processed && card.draw > 0) {
                extra += card.draw;
                card.processed = true;
              }
            });
            if (extra <= 0 || !deckCopy.length) break;
            const drawCount = Math.min(extra, deckCopy.length);
            const extras = deckCopy.splice(0, drawCount);
            extras.forEach(card => card.processed = false);
            hand = hand.concat(extras);
            if (checkHandTemplates(hand, templates)) {
              success = true;
              break;
            }
          }
        }
        if (success) successes++;
      }
      const perc = (successes / trials * 100).toFixed(2);
      const resElem = document.getElementById('calcResult');
      resElem.textContent = `Result: ${successes} successes out of ${trials} trials (${perc}%)`;
      resElem.style.display = "block";
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function checkHandTemplates(hand, templates) {
      for (const template of templates) {
        if (checkTemplate(hand, template)) return true;
      }
      return false;
    }

    function checkTemplate(hand, conditions) {
      for (const condition of conditions) {
        if (condition.exclude && handMatches(hand, condition.value)) return false;
      }
      const includes = conditions.filter(c => !c.exclude);
      if (!includes.length) return true;
      return canSatisfy(includes, hand);
    }

    function handMatches(hand, value) {
      return hand.some(card => cardMatches(card, value));
    }

    function cardMatches(card, value) {
      if (value === "[any card]") return true;
      return card.name === value || (card.tags && card.tags.includes(value));
    }

    function canSatisfy(conditions, cards) {
      if (!conditions.length) return true;
      for (let i = 0; i < cards.length; i++) {
        if (cardMatches(cards[i], conditions[0].value)) {
          const remaining = cards.slice(0, i).concat(cards.slice(i + 1));
          if (canSatisfy(conditions.slice(1), remaining)) return true;
        }
      }
      return false;
    }

    // =============================
    // Theme Toggle Functions
    // =============================
    const themeToggleBtn = document.getElementById("themeToggle");

    function applyTheme(theme) {
      if (theme === "light") {
        document.body.classList.add("light-mode");
        themeToggleBtn.textContent = "üåô";
      } else {
        document.body.classList.remove("light-mode");
        themeToggleBtn.textContent = "‚òÄÔ∏è";
      }
    }

    function toggleTheme() {
      const current = localStorage.getItem("theme") || "dark";
      const next = current === "dark" ? "light" : "dark";
      localStorage.setItem("theme", next);
      applyTheme(next);
    }
    themeToggleBtn.addEventListener("click", toggleTheme);

    // =============================
    // Initialization (DOMContentLoaded)
    // =============================
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize decklist and hand container
      initDecklist([]);
      initHandContainer();

      // Attach event listeners for controls
      document.getElementById('importDeckButton').addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });
      document.getElementById('calculateButton').addEventListener('click', runSimulation);
      document.getElementById('handSizeInput').addEventListener('input', () => {
        updateAllHandRows();
        updateHandSelectOptions();
      });

      // Apply saved theme or default to dark mode
      applyTheme(localStorage.getItem("theme") || "dark");
    });
  </script>
</body>
</html>
