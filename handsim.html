<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yu-Gi-Oh! Hand simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #e0e0e0;
      transition: background-color 0.3s, color 0.3s;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    /* Description under title */
    #description {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.1em;
    }
    /* Top Controls Styles */
    .top-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
      justify-content: center;
      margin-bottom: 10px;
    }
    .top-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .top-controls button:hover {
      background-color: #777;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .control-group label {
      white-space: nowrap;
    }
    .control-group input[type="number"] {
      width: 100px;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    #calcResult {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      border: 2px solid;
      border-radius: 4px;
      width: 100%;
      margin-top: 10px;
      display: none;
    }
    /* Row Layout */
    .row {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .left-pane, .right-pane {
      background: #2e2e2e;
      padding: 10px;
      border-radius: 6px;
    }
    .left-pane {
      flex: 2;
      min-height: 600px;
    }
    .right-pane {
      flex: 1;
    }
    /* Header Container Styles for Both Panes */
    .deck-header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: nowrap;
      margin-bottom: 10px;
    }
    .deck-header {
      font-size: 1.2em;
      font-weight: bold;
    }
    .deck-header-container button {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .deck-header-container button:hover {
      background-color: #777;
    }
    /* Decklist Styles */
    .decklist-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .decklist-row input[type="number"] {
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .decklist-row input[type="number"].qty-field {
      width: 60px;
    }
    .decklist-row input.card-name {
      flex: 2;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .decklist-row input.aka-field {
      flex: 1;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    /* New Draw Field styling */
    .decklist-row input.draw-field {
      width: 60px;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    /* Decklist Buttons */
    .decklist-buttons {
      display: flex;
      gap: 5px;
    }
    .decklist-buttons button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .decklist-buttons button:hover {
      background-color: #777;
    }
    /* Hand Building Interface Styles */
    .hand-size-control {
      margin: 0;
      display: flex;
      align-items: center;
    }
    .hand-size-control label {
      margin-right: 5px;
      white-space: nowrap;
    }
    .hand-size-control input {
      width: 50px;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .hand-box {
      border: 1px solid #555;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .hand-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 5px;
    }
    /* New wrapper for each hand card and its toggle */
    .hand-card-wrapper {
      display: flex;
      align-items: center;
    }
    .hand-card {
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
      -webkit-appearance: menulist-button;
      -moz-appearance: menulist-button;
      appearance: menulist-button;
    }
    /* üõá Toggle Button */
    .hand-toggle {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2em;
      margin-left: 5px;
    }
    .hand-toggle.active {
      color: red;
    }
    .hand-controls {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-top: 5px;
    }
    .hand-controls button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .hand-controls button:hover {
      background-color: #777;
    }
    /* Light mode overrides */
    body.light-mode {
      background-color: #f7f7f7;
      color: #000;
    }
    body.light-mode .container {
      background: #fff;
      color: #000;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    body.light-mode .left-pane, 
    body.light-mode .right-pane {
      background: #f0f0f0;
      color: #000;
    }
    body.light-mode input[type="number"],
    body.light-mode input[type="text"] {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .decklist-buttons button,
    body.light-mode .hand-controls button,
    body.light-mode .top-controls button,
    body.light-mode .deck-header-container button {
      background-color: #ccc;
      color: #000;
    }
    body.light-mode .decklist-buttons button:hover,
    body.light-mode .hand-controls button:hover,
    body.light-mode .top-controls button:hover,
    body.light-mode .deck-header-container button:hover {
      background-color: #aaa;
    }
    body.light-mode .hand-card {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .hand-size-control input,
    body.light-mode .control-group input[type="number"] {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    body.light-mode .decklist-row input.draw-field {
      background: #fff;
      color: #000;
      border-color: #ccc;
    }
    /* Fixed containers for theme toggle and donate button */
    #themeContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1001;
    }
    #themeToggle {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background-color: transparent;
      color: inherit;
      font-size: 1.5em;
      cursor: pointer;
      transition: background 0.3s;
    }
    body:not(.light-mode) #themeToggle:hover {
      background-color: rgba(255,255,255,0.2);
    }
    body.light-mode #themeToggle:hover {
      background-color: rgba(0,0,0,0.1);
    }
    #donateContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Yu-Gi-Oh! Hand simulator</h1>
    <p id="description">
      This tool simulates drawing hands from your Yu-Gi-Oh! deck. Import your deck, set up your hand criteria (including ‚Äúnot‚Äù exclusions and draw effects), choose the number of trials and hand size, then click Calculate to see how often you get a successful hand.
    </p>
    
    <!-- Top Controls (on one line) -->
    <div class="top-controls">
      <div class="control-group">
        <label for="numTrials">Number of test hands to draw:</label>
        <input type="number" id="numTrials" value="100" min="1">
      </div>
      <button id="calculateButton">Calculate</button>
    </div>
    <!-- Result appears on a new row -->
    <div id="calcResult">Result: Placeholder</div>
    
    <div class="row">
      <div class="left-pane">
        <!-- Decklist Header with Import Control -->
        <div class="deck-header-container">
          <div id="decklistHeader" class="deck-header">Main Deck (0)</div>
          <button id="importDeckButton">Import deck...</button>
        </div>
        <div id="decklistContainer">
          <!-- Decklist rows will be dynamically added here -->
        </div>
      </div>
      <div class="right-pane">
        <!-- Build Hands Header with Hand Size Control on one line -->
        <div class="deck-header-container">
          <div id="handHeader" class="deck-header">Build Hands</div>
          <div class="hand-size-control">
            <label for="handSizeInput">Hand Size:</label>
            <input type="number" id="handSizeInput" value="5" min="1">
          </div>
        </div>
        <div id="handContainer">
          <!-- Hand boxes will be dynamically added here -->
        </div>
        <!-- Datalist for hand dropdown options -->
        <datalist id="handOptions"></datalist>
      </div>
    </div>
    
    <!-- Hidden file input remains for deck import -->
    <input type="file" id="fileInput" accept=".ydk" style="display: none;">
  </div>
  
  <!-- Light/Dark Theme Toggle -->
  <div id="themeContainer">
    <button id="themeToggle">‚òÄÔ∏è</button>
  </div>
  
  <!-- Donate Button -->
  <div id="donateContainer">
    <script type="text/javascript" src="https://storage.ko-fi.com/cdn/widget/Widget_2.js"></script>
    <script type="text/javascript">
      kofiwidget2.init('Support the dev', '#72a4f2', 'Q5Q51BKX92');
      kofiwidget2.draw();
    </script>
  </div>
  
  <script>
    // ------------------------------
    // Editable Decklist Functions
    // ------------------------------
    function createDecklistRow(quantity = 1, cardName = "", tags = "", draw = 0) {
      const row = document.createElement('div');
      row.className = 'decklist-row';
      
      const qtyInput = document.createElement('input');
      qtyInput.type = 'number';
      qtyInput.min = 1;
      qtyInput.value = quantity;
      qtyInput.classList.add("qty-field");
      qtyInput.addEventListener('input', () => {
        updateDeckHeader();
        updateHandOptions();
      });
      
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.placeholder = 'Card Name';
      nameInput.value = cardName;
      nameInput.classList.add('card-name');
      nameInput.addEventListener('input', updateHandOptions);
      
      const tagsInput = document.createElement('input');
      tagsInput.type = 'text';
      tagsInput.placeholder = 'List Tags: Starter, Handtrap, etc';
      tagsInput.value = tags;
      tagsInput.classList.add('aka-field');
      tagsInput.addEventListener('input', updateHandOptions);
      
      const drawInput = document.createElement('input');
      drawInput.type = 'number';
      drawInput.min = 0;
      drawInput.value = draw;
      drawInput.classList.add('draw-field');
      drawInput.placeholder = 'Draw';
      drawInput.addEventListener('input', () => {
        // You may call a function to update calculations if needed.
      });
      
      const btnContainer = document.createElement('div');
      btnContainer.className = 'decklist-buttons';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.title = 'Add a new decklist row below';
      addBtn.addEventListener('click', () => {
        const newRow = createDecklistRow();
        row.parentNode.insertBefore(newRow, row.nextSibling);
        updateDeckHeader();
        updateHandOptions();
      });
      
      const removeBtn = document.createElement('button');
      removeBtn.textContent = '‚Äì';
      removeBtn.title = 'Remove this decklist row';
      removeBtn.addEventListener('click', () => {
        const container = document.getElementById('decklistContainer');
        if (container.querySelectorAll('.decklist-row').length > 1) {
          row.remove();
          updateDeckHeader();
          updateHandOptions();
        } else {
          qtyInput.value = 1;
          nameInput.value = "";
          tagsInput.value = "";
          drawInput.value = 0;
          updateDeckHeader();
          updateHandOptions();
        }
      });
      
      btnContainer.appendChild(addBtn);
      btnContainer.appendChild(removeBtn);
      
      row.appendChild(qtyInput);
      row.appendChild(nameInput);
      row.appendChild(tagsInput);
      row.appendChild(drawInput);
      row.appendChild(btnContainer);
      
      return row;
    }
    
    function updateDeckHeader() {
      const container = document.getElementById('decklistContainer');
      let total = 0;
      container.querySelectorAll('.decklist-row').forEach(row => {
        const qtyInput = row.querySelector('input.qty-field');
        total += parseInt(qtyInput.value) || 0;
      });
      document.getElementById('decklistHeader').textContent = `Main Deck (${total})`;
    }
    
    function initDecklist(data) {
      const container = document.getElementById('decklistContainer');
      container.innerHTML = "";
      if (data.length === 0) {
        container.appendChild(createDecklistRow());
      } else {
        data.forEach(item => {
          container.appendChild(createDecklistRow(item.quantity, item.cardName, item.tags || "", item.draw || 0));
        });
      }
      updateDeckHeader();
      updateHandOptions();
      document.dispatchEvent(new Event('decklistLoaded'));
    }
    
    // ------------------------------
    // Hand Building Functions
    // ------------------------------
    function updateHandOptions() {
      const deckContainer = document.getElementById('decklistContainer');
      const optionsSet = new Set();
      deckContainer.querySelectorAll('.decklist-row').forEach(row => {
        const cardName = row.querySelector('input.card-name').value.trim();
        if (cardName) {
          optionsSet.add(cardName);
        }
        const tagsText = row.querySelector('input.aka-field').value;
        if (tagsText) {
          tagsText.split(',').forEach(tag => {
            const trimmed = tag.trim();
            if (trimmed) {
              optionsSet.add(trimmed);
            }
          });
        }
      });
      const optionsArray = Array.from(optionsSet);
      optionsArray.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      optionsArray.unshift("[Any Card]");
      
      const datalist = document.getElementById('handOptions');
      datalist.innerHTML = "";
      optionsArray.forEach(opt => {
        const optionElem = document.createElement('option');
        optionElem.value = opt;
        datalist.appendChild(optionElem);
      });
      updateAllHandRows();
      updateHandSelectOptions();
    }
    
    function updateHandSelectOptions() {
      const datalist = document.getElementById('handOptions');
      const newOptions = Array.from(datalist.options).map(opt => ({ value: opt.value, text: opt.value }));
      document.querySelectorAll('select.hand-card').forEach(select => {
        const currentVal = select.value;
        select.innerHTML = "";
        const defaultOption = document.createElement('option');
        defaultOption.textContent = "Card name or tag";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        select.appendChild(defaultOption);
        newOptions.forEach(optData => {
          const optionElem = document.createElement('option');
          optionElem.value = optData.value;
          optionElem.textContent = optData.text;
          select.appendChild(optionElem);
        });
        const allowedValues = newOptions.map(opt => opt.value);
        if (allowedValues.includes(currentVal)) {
          select.value = currentVal;
        }
      });
    }
    
    function validateHandCardInput(input) {
      let value = input.value.trim();
      if (!value) return;
      const datalist = document.getElementById('handOptions');
      const allowed = Array.from(datalist.options).map(opt => opt.value);
      if (allowed.includes(value)) {
        return;
      } else {
        const matched = allowed.find(v => v.toLowerCase() === value.toLowerCase());
        if (matched) {
          input.value = matched;
        } else {
          input.value = "";
        }
      }
    }
    
    function createHandRow() {
      const box = document.createElement('div');
      box.className = 'hand-box';
      
      const row = document.createElement('div');
      row.className = 'hand-row';
      const handSize = parseInt(document.getElementById('handSizeInput').value) || 5;
      for (let i = 0; i < handSize; i++) {
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'hand-card-wrapper';
        
        const handCard = document.createElement('select');
        handCard.className = 'hand-card';
        const defaultOption = document.createElement('option');
        defaultOption.textContent = "Card name or tag";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        handCard.appendChild(defaultOption);
        const datalist = document.getElementById('handOptions');
        Array.from(datalist.options).forEach(opt => {
          const optionElem = document.createElement('option');
          optionElem.value = opt.value;
          optionElem.textContent = opt.value;
          handCard.appendChild(optionElem);
        });
        handCard.addEventListener('blur', () => {
          validateHandCardInput(handCard);
        });
        
        const toggleButton = document.createElement('button');
        toggleButton.className = 'hand-toggle';
        toggleButton.textContent = 'üõá';
        toggleButton.addEventListener('click', (e) => {
          e.preventDefault();
          toggleButton.classList.toggle('active');
          handCard.dataset.exclude = toggleButton.classList.contains('active');
        });
        
        cardWrapper.appendChild(handCard);
        cardWrapper.appendChild(toggleButton);
        row.appendChild(cardWrapper);
      }
      
      const controlContainer = document.createElement('div');
      controlContainer.className = 'hand-controls';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.title = 'Add a new hand row below';
      addBtn.addEventListener('click', () => {
        const newBox = createHandRow();
        box.parentNode.insertBefore(newBox, box.nextSibling);
      });
      
      const removeBtn = document.createElement('button');
      removeBtn.textContent = '‚Äì';
      removeBtn.title = 'Remove this hand row';
      removeBtn.addEventListener('click', () => {
        const container = document.getElementById('handContainer');
        if (container.children.length > 1) {
          box.remove();
        } else {
          row.querySelectorAll('select.hand-card').forEach(select => select.selectedIndex = 0);
        }
      });
      
      const duplicateBtn = document.createElement('button');
      duplicateBtn.textContent = '‚ßâ';
      duplicateBtn.title = 'Duplicate this hand row';
      duplicateBtn.addEventListener('click', () => {
        const newBox = createHandRow();
        const currentSelects = box.querySelectorAll('select.hand-card');
        const newSelects = newBox.querySelectorAll('select.hand-card');
        currentSelects.forEach((select, i) => {
          newSelects[i].value = select.value;
        });
        box.parentNode.insertBefore(newBox, box.nextSibling);
      });
      
      controlContainer.appendChild(addBtn);
      controlContainer.appendChild(removeBtn);
      controlContainer.appendChild(duplicateBtn);
      
      box.appendChild(row);
      box.appendChild(controlContainer);
      return box;
    }
    
    function updateAllHandRows() {
      const handSize = parseInt(document.getElementById('handSizeInput').value) || 5;
      const handContainer = document.getElementById('handContainer');
      handContainer.querySelectorAll('.hand-box').forEach(box => {
        const row = box.querySelector('.hand-row');
        const currentCount = row.querySelectorAll('.hand-card').length;
        if (currentCount < handSize) {
          for (let i = currentCount; i < handSize; i++) {
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'hand-card-wrapper';
            
            const handCard = document.createElement('select');
            handCard.className = 'hand-card';
            const defaultOption = document.createElement('option');
            defaultOption.textContent = "Card name or tag";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            handCard.appendChild(defaultOption);
            const datalist = document.getElementById('handOptions');
            Array.from(datalist.options).forEach(opt => {
              const optionElem = document.createElement('option');
              optionElem.value = opt.value;
              optionElem.textContent = opt.value;
              handCard.appendChild(optionElem);
            });
            handCard.addEventListener('blur', () => {
              validateHandCardInput(handCard);
            });
            
            const toggleButton = document.createElement('button');
            toggleButton.className = 'hand-toggle';
            toggleButton.textContent = 'üõá';
            toggleButton.addEventListener('click', (e) => {
              e.preventDefault();
              toggleButton.classList.toggle('active');
              handCard.dataset.exclude = toggleButton.classList.contains('active');
            });
            
            cardWrapper.appendChild(handCard);
            cardWrapper.appendChild(toggleButton);
            row.appendChild(cardWrapper);
          }
        } else if (currentCount > handSize) {
          for (let i = currentCount; i > handSize; i--) {
            const cardWrappers = row.querySelectorAll('.hand-card-wrapper');
            cardWrappers[cardWrappers.length - 1].remove();
          }
        }
      });
      updateHandSelectOptions();
    }
    
    function initHandContainer() {
      const container = document.getElementById('handContainer');
      container.innerHTML = "";
      container.appendChild(createHandRow());
    }
    
    // ------------------------------
    // File Parsing and Integration
    // ------------------------------
    function parseYDK(text) {
      const lines = text.split(/\r?\n/);
      const main = [];
      let currentSection = "main";
      for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        if (line.startsWith("#")) {
          currentSection = (line.toLowerCase() === "#main") ? "main" : "other";
          continue;
        }
        if (line.startsWith("!")) {
          currentSection = "other";
          continue;
        }
        if (!isNaN(line) && currentSection === "main") {
          main.push(line);
        }
      }
      return main;
    }
    
    async function fetchCardDetails(ids) {
      const uniqueIds = Array.from(new Set(ids));
      const parameter = uniqueIds.join(",");
      const response = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?utm_source=storm-access&misc=yes&id=${parameter}`);
      const payload = await response.json();
      const cardMap = new Map();
      for (const card of payload.data) {
        cardMap.set(String(card.id), card);
      }
      return cardMap;
    }
    
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(event) {
        const text = event.target.result;
        const mainDeckIDs = parseYDK(text);
        if (mainDeckIDs.length === 0) {
          alert('No cards found in the file.');
          return;
        }
        try {
          const cardMap = await fetchCardDetails(mainDeckIDs);
          const counts = {};
          mainDeckIDs.forEach(id => {
            counts[id] = (counts[id] || 0) + 1;
          });
          const deckData = [];
          for (const id in counts) {
            const card = cardMap.get(id);
            deckData.push({ 
              quantity: counts[id], 
              cardName: card ? card.name : `Unknown card (ID: ${id})`, 
              tags: "",
              draw: 0
            });
          }
          initDecklist(deckData);
        } catch (err) {
          alert('Error fetching card details: ' + err);
        }
      }
      reader.readAsText(file);
    });
    
    document.addEventListener('DOMContentLoaded', () => {
      initDecklist([]);
      initHandContainer();
    });
  </script>
  
  <!-- New Controls Script -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Trigger hidden file input when "Import deck..." is clicked
      document.getElementById('importDeckButton').addEventListener('click', function() {
        document.getElementById('fileInput').click();
      });
      
      // Calculate button now runs the simulation
      document.getElementById('calculateButton').addEventListener('click', function() {
        runSimulation();
      });
      
      // Update hand rows when hand size changes
      document.getElementById('handSizeInput').addEventListener('input', function() {
        updateAllHandRows();
        updateHandSelectOptions();
      });
    });
    
    // ------------------------------
    // Simulation Logic
    // ------------------------------
    function runSimulation() {
      const numTrials = parseInt(document.getElementById('numTrials').value) || 100;
      
      // Build deck array from decklist rows
      const deck = [];
      document.querySelectorAll('#decklistContainer .decklist-row').forEach(row => {
        const qty = parseInt(row.querySelector('input.qty-field').value) || 0;
        const cardName = row.querySelector('input.card-name').value.trim();
        const tagsText = row.querySelector('input.aka-field').value.trim();
        const draw = parseInt(row.querySelector('input.draw-field').value) || 0;
        let tags = [];
        if (tagsText) {
          tags = tagsText.split(',').map(t => t.trim().toLowerCase());
        }
        const nameLower = cardName.toLowerCase();
        for (let i = 0; i < qty; i++) {
          deck.push({
            name: nameLower,
            tags: tags,
            draw: draw
          });
        }
      });
      
      if (deck.length === 0) {
        alert("Deck is empty!");
        return;
      }
      
      // Build hand templates from hand container
      const templates = [];
      document.querySelectorAll('#handContainer .hand-box').forEach(box => {
        const conditions = [];
        const selects = box.querySelectorAll('.hand-row select.hand-card');
        selects.forEach(select => {
          const val = select.value.trim();
          if (val === "" || val === "Card name or tag") return;
          conditions.push({
            value: val.toLowerCase(),
            exclude: (select.dataset.exclude === "true")
          });
        });
        if (conditions.length > 0) {
          templates.push(conditions);
        }
      });
      
      if (templates.length === 0) {
        alert("No hand templates defined!");
        return;
      }
      
      let successCount = 0;
      for (let trial = 0; trial < numTrials; trial++) {
        // Create a copy of the deck and shuffle it
        let deckCopy = deck.slice();
        shuffle(deckCopy);
        const handSize = parseInt(document.getElementById('handSizeInput').value) || 5;
        let hand = deckCopy.splice(0, handSize);
        // Mark drawn cards as not processed for draw effects
        hand.forEach(card => { card.processed = false; });
        
        let trialSuccess = false;
        if (checkHandTemplates(hand, templates)) {
          trialSuccess = true;
        } else {
          // Process draw chaining
          while (true) {
            let drawCount = 0;
            hand.forEach(card => {
              if (!card.processed && card.draw > 0) {
                drawCount += card.draw;
                card.processed = true;
              }
            });
            if (drawCount <= 0) break;
            if (deckCopy.length === 0) break;
            let additional = deckCopy.splice(0, drawCount);
            additional.forEach(card => { card.processed = false; });
            hand = hand.concat(additional);
            if (checkHandTemplates(hand, templates)) {
              trialSuccess = true;
              break;
            }
          }
        }
        if (trialSuccess) successCount++;
      }
      
      const resultText = `Result: ${successCount} successes out of ${numTrials} trials (${((successCount/numTrials)*100).toFixed(2)}%)`;
      const resultElem = document.getElementById('calcResult');
      resultElem.textContent = resultText;
      resultElem.style.display = "block";
    }
    
    // Fisher-Yates shuffle
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    // Check if hand satisfies any of the templates
    function checkHandTemplates(hand, templates) {
      for (let template of templates) {
        if (checkTemplate(hand, template)) return true;
      }
      return false;
    }
    
    // Check a single template: first test exclude conditions, then try to satisfy include conditions
    function checkTemplate(hand, conditions) {
      // Check excludes: if any exclude condition is matched, template fails.
      for (let cond of conditions) {
        if (cond.exclude) {
          if (handMatchesCondition(hand, cond.value)) {
            return false;
          }
        }
      }
      // Gather include conditions
      let includes = conditions.filter(cond => !cond.exclude);
      if (includes.length === 0) return true;
      return canSatisfyConditions(includes, hand);
    }
    
    // For exclude conditions: does any card in hand match the condition?
    function handMatchesCondition(hand, condValue) {
      for (let card of hand) {
        if (cardMatches(card, condValue)) {
          return true;
        }
      }
      return false;
    }
    
    // Check if a card matches a condition (by name or tag). "[Any Card]" always matches.
    function cardMatches(card, condValue) {
      if (condValue === "[any card]") return true;
      if (card.name === condValue) return true;
      if (card.tags && card.tags.includes(condValue)) return true;
      return false;
    }
    
    // Recursive matching for include conditions (each card used at most once)
    function canSatisfyConditions(conditions, handCards) {
      if (conditions.length === 0) return true;
      for (let i = 0; i < handCards.length; i++) {
        if (cardMatches(handCards[i], conditions[0].value)) {
          let remaining = handCards.slice(0, i).concat(handCards.slice(i+1));
          if (canSatisfyConditions(conditions.slice(1), remaining)) return true;
        }
      }
      return false;
    }
  </script>
  
  <!-- Theme Toggle Script -->
  <script>
    const themeToggleBtn = document.getElementById("themeToggle");
    const applyTheme = theme => {
      if (theme === "light") {
        document.body.classList.add("light-mode");
        themeToggleBtn.textContent = "üåô";
      } else {
        document.body.classList.remove("light-mode");
        themeToggleBtn.textContent = "‚òÄÔ∏è";
      }
    };
    const toggleTheme = () => {
      const current = localStorage.getItem("theme") || "dark";
      const next = current === "dark" ? "light" : "dark";
      localStorage.setItem("theme", next);
      applyTheme(next);
    };
    themeToggleBtn.addEventListener("click", toggleTheme);
    const initTheme = () => {
      const saved = localStorage.getItem("theme") || "dark";
      applyTheme(saved);
    };
    document.addEventListener("DOMContentLoaded", initTheme);
  </script>
</body>
</html>
