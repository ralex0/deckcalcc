<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yu-Gi-Oh! Hand simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #e0e0e0;
      transition: background-color 0.3s, color 0.3s;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    input[type="file"] {
      display: block;
      margin: 0 auto 20px auto;
    }
    .row {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .left-pane, .right-pane {
      background: #2e2e2e;
      padding: 10px;
      border-radius: 6px;
    }
    .left-pane {
      flex: 2;
      min-height: 600px;
    }
    .right-pane {
      flex: 1;
    }
    /* Decklist Styles */
    .deck-header {
      font-size: 1.2em;
      margin-bottom: 10px;
      text-align: center;
      font-weight: bold;
    }
    .decklist-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .decklist-row input[type="number"] {
      width: 60px;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .decklist-row input.card-name {
      flex: 2;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .decklist-row input.aka-field {
      flex: 1;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    .decklist-buttons {
      display: flex;
      gap: 5px;
    }
    .decklist-buttons button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .decklist-buttons button:hover {
      background-color: #777;
    }
    /* Hand Building Interface Styles */
    .hand-size-control {
      margin-bottom: 10px;
      text-align: center;
    }
    .hand-size-control label {
      margin-right: 5px;
    }
    .hand-size-control input {
      width: 50px;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
    }
    /* Each hand box is visually separated */
    .hand-box {
      border: 1px solid #555;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .hand-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 5px;
    }
    /* Hand card input styled to look like a drop-down */
    .hand-card {
      flex: 1;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2e2e2e;
      color: #e0e0e0;
      -webkit-appearance: menulist-button;
      -moz-appearance: menulist-button;
      appearance: menulist-button;
    }
    /* Hand controls grouped on one row */
    .hand-controls {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-top: 5px;
    }
    .hand-controls button {
      width: 30px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    .hand-controls button:hover {
      background-color: #777;
    }
    #addHandButton {
      display: block;
      margin: 10px auto;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #555;
      color: #e0e0e0;
      transition: background 0.3s;
    }
    #addHandButton:hover {
      background-color: #777;
    }
    .right-pane h2 {
      margin-top: 0;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Yu-Gi-Oh! Hand simulator</h1>
    <input type="file" id="fileInput" accept=".ydk">
    <div class="row">
      <div class="left-pane">
        <!-- Editable decklist header and container -->
        <div id="decklistHeader" class="deck-header">Main Deck (0)</div>
        <div id="decklistContainer">
          <!-- Decklist rows will be dynamically added here -->
        </div>
      </div>
      <div class="right-pane">
        <h2>Build Hands</h2>
        <div class="hand-size-control">
          <label for="handSizeInput">Hand Size:</label>
          <input type="number" id="handSizeInput" value="5" min="1">
        </div>
        <div id="handContainer">
          <!-- Hand boxes will be dynamically added here -->
        </div>
        <button id="addHandButton">Add Hand</button>
        <!-- Datalist for hand dropdown options -->
        <datalist id="handOptions"></datalist>
      </div>
    </div>
  </div>
  <script>
    // ------------------------------
    // Editable Decklist Functions
    // ------------------------------
    function createDecklistRow(quantity = 1, cardName = "", tags = "") {
      const row = document.createElement('div');
      row.className = 'decklist-row';
      
      const qtyInput = document.createElement('input');
      qtyInput.type = 'number';
      qtyInput.min = 1;
      qtyInput.value = quantity;
      qtyInput.addEventListener('input', () => {
        updateDeckHeader();
        updateHandOptions();
      });
      
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.placeholder = 'Card Name';
      nameInput.value = cardName;
      nameInput.classList.add('card-name');
      nameInput.addEventListener('input', updateHandOptions);
      
      const tagsInput = document.createElement('input');
      tagsInput.type = 'text';
      tagsInput.placeholder = 'List Tags: Starter, Handtrap, etc';
      tagsInput.value = tags;
      tagsInput.classList.add('aka-field');
      tagsInput.addEventListener('input', updateHandOptions);
      
      const btnContainer = document.createElement('div');
      btnContainer.className = 'decklist-buttons';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.title = 'Add a new decklist row below';
      addBtn.addEventListener('click', () => {
        const newRow = createDecklistRow();
        row.parentNode.insertBefore(newRow, row.nextSibling);
        updateDeckHeader();
        updateHandOptions();
      });
      
      const removeBtn = document.createElement('button');
      removeBtn.textContent = '–';
      removeBtn.title = 'Remove this decklist row';
      removeBtn.addEventListener('click', () => {
        const container = document.getElementById('decklistContainer');
        if (container.querySelectorAll('.decklist-row').length > 1) {
          row.remove();
          updateDeckHeader();
          updateHandOptions();
        } else {
          qtyInput.value = 1;
          nameInput.value = "";
          tagsInput.value = "";
          updateDeckHeader();
          updateHandOptions();
        }
      });
      
      btnContainer.appendChild(addBtn);
      btnContainer.appendChild(removeBtn);
      
      row.appendChild(qtyInput);
      row.appendChild(nameInput);
      row.appendChild(tagsInput);
      row.appendChild(btnContainer);
      
      return row;
    }
    
    function updateDeckHeader() {
      const container = document.getElementById('decklistContainer');
      let total = 0;
      container.querySelectorAll('.decklist-row').forEach(row => {
        const qtyInput = row.querySelector('input[type="number"]');
        total += parseInt(qtyInput.value) || 0;
      });
      document.getElementById('decklistHeader').textContent = `Main Deck (${total})`;
    }
    
    function initDecklist(data) {
      const container = document.getElementById('decklistContainer');
      container.innerHTML = "";
      if (data.length === 0) {
        container.appendChild(createDecklistRow());
      } else {
        data.forEach(item => {
          container.appendChild(createDecklistRow(item.quantity, item.cardName, item.tags || ""));
        });
      }
      updateDeckHeader();
      updateHandOptions();
    }
    
    // ------------------------------
    // Hand Building Functions
    // ------------------------------
    // updateHandOptions() collects card names and tags from the decklist and updates the datalist.
    function updateHandOptions() {
      const deckContainer = document.getElementById('decklistContainer');
      const optionsSet = new Set();
      deckContainer.querySelectorAll('.decklist-row').forEach(row => {
        const cardName = row.querySelector('input.card-name').value.trim();
        if (cardName) {
          optionsSet.add(cardName);
        }
        const tagsText = row.querySelector('input.aka-field').value;
        if (tagsText) {
          tagsText.split(',').forEach(tag => {
            const trimmed = tag.trim();
            if (trimmed) {
              optionsSet.add(trimmed);
            }
          });
        }
      });
      // Include default option "[Any Card]"
      const optionsArray = Array.from(optionsSet);
      optionsArray.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      optionsArray.unshift("[Any Card]");
      
      const datalist = document.getElementById('handOptions');
      datalist.innerHTML = "";
      optionsArray.forEach(opt => {
        const optionElem = document.createElement('option');
        optionElem.value = opt;
        datalist.appendChild(optionElem);
      });
      updateAllHandRows();
    }
    
    // Helper: Validate a hand card input.
    function validateHandCardInput(input) {
      let value = input.value.trim();
      if (!value) return;
      // Gather allowed options from the datalist.
      const datalist = document.getElementById('handOptions');
      const allowed = Array.from(datalist.options).map(opt => opt.value);
      if (allowed.includes(value)) {
        return; // Valid as-is.
      } else {
        // Check for a case-insensitive match.
        const matched = allowed.find(v => v.toLowerCase() === value.toLowerCase());
        if (matched) {
          input.value = matched;
        } else {
          input.value = "";
        }
      }
    }
    
    // createHandRow() creates a hand box containing a row of dropdowns and control buttons.
    function createHandRow() {
      const box = document.createElement('div');
      box.className = 'hand-box';
      
      const row = document.createElement('div');
      row.className = 'hand-row';
      const handSize = parseInt(document.getElementById('handSizeInput').value) || 5;
      for (let i = 0; i < handSize; i++) {
        const handCard = document.createElement('input');
        handCard.type = 'text';
        handCard.className = 'hand-card';
        handCard.placeholder = 'Card name or tag';
        handCard.setAttribute('list', 'handOptions');
        // Validate when focus is lost.
        handCard.addEventListener('blur', () => {
          validateHandCardInput(handCard);
        });
        row.appendChild(handCard);
      }
      
      const controlContainer = document.createElement('div');
      controlContainer.className = 'hand-controls';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = '+';
      addBtn.title = 'Add a new hand row below';
      addBtn.addEventListener('click', () => {
        const newBox = createHandRow();
        box.parentNode.insertBefore(newBox, box.nextSibling);
      });
      
      const removeBtn = document.createElement('button');
      removeBtn.textContent = '–';
      removeBtn.title = 'Remove this hand row';
      removeBtn.addEventListener('click', () => {
        const container = document.getElementById('handContainer');
        if (container.children.length > 1) {
          box.remove();
        } else {
          row.querySelectorAll('input.hand-card').forEach(input => input.value = "");
        }
      });
      
      const duplicateBtn = document.createElement('button');
      duplicateBtn.textContent = '⧉';
      duplicateBtn.title = 'Duplicate this hand row';
      duplicateBtn.addEventListener('click', () => {
        const newBox = createHandRow();
        // Copy current hand card values into the duplicate.
        const currentInputs = box.querySelectorAll('input.hand-card');
        const newInputs = newBox.querySelectorAll('input.hand-card');
        currentInputs.forEach((input, i) => {
          newInputs[i].value = input.value;
        });
        box.parentNode.insertBefore(newBox, box.nextSibling);
      });
      
      controlContainer.appendChild(addBtn);
      controlContainer.appendChild(removeBtn);
      controlContainer.appendChild(duplicateBtn);
      
      box.appendChild(row);
      box.appendChild(controlContainer);
      return box;
    }
    
    function updateAllHandRows() {
      const handSize = parseInt(document.getElementById('handSizeInput').value) || 5;
      const handContainer = document.getElementById('handContainer');
      handContainer.querySelectorAll('.hand-box').forEach(box => {
        const row = box.querySelector('.hand-row');
        const currentCount = row.querySelectorAll('input.hand-card').length;
        if (currentCount < handSize) {
          for (let i = currentCount; i < handSize; i++) {
            const handCard = document.createElement('input');
            handCard.type = 'text';
            handCard.className = 'hand-card';
            handCard.placeholder = 'Card name or tag';
            handCard.setAttribute('list', 'handOptions');
            handCard.addEventListener('blur', () => {
              validateHandCardInput(handCard);
            });
            row.appendChild(handCard);
          }
        } else if (currentCount > handSize) {
          for (let i = currentCount; i > handSize; i--) {
            const inputs = row.querySelectorAll('input.hand-card');
            inputs[inputs.length - 1].remove();
          }
        }
      });
    }
    
    function initHandContainer() {
      const container = document.getElementById('handContainer');
      container.innerHTML = "";
      container.appendChild(createHandRow());
    }
    
    // ------------------------------
    // Event Listeners
    // ------------------------------
    document.getElementById('handSizeInput').addEventListener('input', () => {
      updateAllHandRows();
    });
    
    document.getElementById('addHandButton').addEventListener('click', () => {
      const container = document.getElementById('handContainer');
      container.appendChild(createHandRow());
    });
    
    // ------------------------------
    // File Parsing and Integration
    // ------------------------------
    function parseYDK(text) {
      const lines = text.split(/\r?\n/);
      const main = [];
      let currentSection = "main";
      for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        if (line.startsWith("#")) {
          currentSection = (line.toLowerCase() === "#main") ? "main" : "other";
          continue;
        }
        if (line.startsWith("!")) {
          currentSection = "other";
          continue;
        }
        if (!isNaN(line) && currentSection === "main") {
          main.push(line);
        }
      }
      return main;
    }
    
    async function fetchCardDetails(ids) {
      const uniqueIds = Array.from(new Set(ids));
      const parameter = uniqueIds.join(",");
      const response = await fetch(`https://db.ygoprodeck.com/api/v7/cardinfo.php?utm_source=storm-access&misc=yes&id=${parameter}`);
      const payload = await response.json();
      const cardMap = new Map();
      for (const card of payload.data) {
        cardMap.set(String(card.id), card);
      }
      return cardMap;
    }
    
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(event) {
        const text = event.target.result;
        const mainDeckIDs = parseYDK(text);
        if (mainDeckIDs.length === 0) {
          alert('No cards found in the file.');
          return;
        }
        try {
          const cardMap = await fetchCardDetails(mainDeckIDs);
          const counts = {};
          mainDeckIDs.forEach(id => {
            counts[id] = (counts[id] || 0) + 1;
          });
          const deckData = [];
          for (const id in counts) {
            const card = cardMap.get(id);
            deckData.push({ quantity: counts[id], cardName: card ? card.name : `Unknown card (ID: ${id})`, tags: "" });
          }
          initDecklist(deckData);
        } catch (err) {
          alert('Error fetching card details: ' + err);
        }
      }
      reader.readAsText(file);
    });
    
    document.addEventListener('DOMContentLoaded', () => {
      initDecklist([]);
      initHandContainer();
    });
  </script>
</body>
</html>
